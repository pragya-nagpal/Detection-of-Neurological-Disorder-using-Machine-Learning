# -*- coding: utf-8 -*-
"""cervical final file.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zSF0qftRHwSHUlTaOHqpGtvGFdFdo1bH
"""

from google.colab import drive
drive.mount('/content/drive')
#250 from here we took cervical code

#blepblink 
import cv2, numpy as np, glob, os,shutil, keras, matplotlib.pyplot as plt,tensorflow as tf,matplotlib.mlab as mplt, sys
from matplotlib import style
from keras.models import Sequential
from keras.models import load_model
from keras.layers import Convolution2D, MaxPooling2D, Dropout,ZeroPadding2D
from keras.layers.core import Dense, Dropout, Activation, Flatten
from keras.optimizers import Adam
from sklearn.model_selection import train_test_split as tt
import scipy.io.wavfile
from math import sqrt
import librosa
from sklearn.metrics import roc_curve, auc, roc_auc_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_recall_curve,f1_score,average_precision_score,confusion_matrix
from keras import backend as K
from keras.callbacks import ModelCheckpoint
from sklearn.preprocessing import StandardScaler as sd
from sklearn.model_selection import StratifiedKFold
import subprocess
from sklearn.decomposition import PCA
from IPython.display import Audio
from keras.models import Model
from keras import optimizers
from imutils import face_utils
import dlib,math
detector= dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor('./drive/My Drive/shape_predictor_68_face_landmarks.dat')

def reye(frame,shape1):
    eye= shape1[39][0] -shape1[36][0] 
    x1=shape1[36][0]
    x1=x1-int(eye*(0.4))
    x2= shape1[39][0] 
    x2=x2+2
    y1=shape1[37][1]
    y1=y1-int(eye*0.6)
    y2=shape1[40][1]
    y2=y2+int(eye*0.6)
    if(x1<0):
        x1=0
    if(y1<0):
        y1=0
    if(x2>frame.shape[1]):
        x2=frame.shape[1]
    if(y2>frame.shape[0]):
        y2=frame.shape[0]   
    x_2=frame[y1:y2, x1:x2]
    
    return x_2
def leye(frame,shape1):
    eye= shape1[45][0] -shape1[42][0] 
    x1=shape1[42][0]
    x1=x1-2
    x2= shape1[45][0] 
    x2=x2+int(eye*(0.4))
    y1= shape1[43][1]
    y1=y1-int(eye*(0.6))
    y2=shape1[47][1]
    y2=y2+int(eye*(0.6))
    if(x1<0):
        x1=0
    if(y1<0):
        y1=0
    if(x2>frame.shape[1]):
        x2=frame.shape[1]
    if(y2>frame.shape[0]):
        y2=frame.shape[0] 
    x_=frame[ y1:y2, x1:x2]
    return x_
def leyen(frame,shape1):
    x= (shape1[42][0]+shape1[45][0])/2.0
    y= (shape1[43][1]+shape1[47][1])/2.0
    nose=shape1[35][0] - shape1[31][0]
    x1= int(x-0.7*nose)
    x2 = int(x+0.9*nose)
    y1=int(y - nose)
    y2=int(y + 0.6*nose)
    if(x1<0):
        x1=0
    if(y1<0):
        y1=0
    if(x2>frame.shape[1]):
        x2=frame.shape[1]
    if(y2>frame.shape[0]):
        y2=frame.shape[0]   
    x_1=frame[y1:y2, x1:x2]
    return x_1
def reyen(frame, shape1):
    x= (shape1[39][0]+shape1[36][0])/2.0
    y= (shape1[37][1]+shape1[41][1])/2.0
    nose=shape1[35][0] - shape1[31][0]
    x1= int(x-0.9*nose)
    x2 = int(x+0.7*nose)
    y1=int(y - nose)
    y2=int(y + 0.6*nose)
    if(x1<0):
        x1=0
    if(y1<0):
        y1=0
    if(x2>frame.shape[1]):
        x2=frame.shape[1]
    if(y2>frame.shape[0]):
        y2=frame.shape[0]   
    x_2=frame[y1:y2, x1:x2]
    return x_2

# eye of interest ko check kr re h.
drop=0.8
learning_rate=.0001
epoch=50
#count=0
model = Sequential()
model.add(Convolution2D(32, (2,2), input_shape=(50,50,1), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))

model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))

model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2), padding='same'))
model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))


model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))


model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))

model.add(Convolution2D(64, 2, activation='relu',padding='same'))
#model.add(ZeroPadding2D((1, 1)))
model.add(MaxPooling2D(pool_size=2,padding='same'))
#model.add(Dropout(0.3))


model.add(Flatten())
model.add(Dense(1024, activation='relu'))
#model.add(Dropout(0.30))
#   model.add(Dense(512, activation='relu'))
#   model.add(Dense(1024, activation='relu'))
model.add(Dropout(drop))
model.add(Dense(2))
model.add(Activation('softmax'))
model.load_weights("./drive/My Drive/neuro/colour.hdf5")
adam=optimizers.Adam(lr=learning_rate)
model.compile(optimizer=adam,loss='categorical_crossentropy', metrics=['accuracy'])

path_dict={0:"./drive/My Drive/neuro/neuro_disorder_data_final/cerv/disease/",1:"./drive/My Drive/neuro/neuro_disorder_data_final/cerv/normal/"}

def angl(gray, shape1):
    size = gray.shape
    image_points = np.array([(shape1[30][0],shape1[30][1]),(shape1[8][0],shape1[8][1]), (shape1[45][0],shape1[45][1]), (shape1[36][0],shape1[36][1]),(shape1[54][0],shape1[54][1]),(shape1[48][0],shape1[48][1]) ], dtype="double")
    model_points = np.array([
                                (0.0, 0.0, 0.0),             # Nose tip
                                (0.0, -330.0, -65.0),        # Chin
                                (-225.0, 170.0, -135.0),     # Left eye left corner
                                (225.0, 170.0, -135.0),      # Right eye right corne
                                (-150.0, -150.0, -125.0),    # Left Mouth corner
                                (150.0, -150.0, -125.0)      # Right mouth corner
                             
                            ])
    focal_length = size[1]
    center = (size[1]/2, size[0]/2)
    camera_matrix = np.array(
                             [[focal_length, 0, center[0]],
                             [0, focal_length, center[1]],
                             [0, 0, 1]], dtype = "double"
                             )
    dist_coeffs = np.zeros((4,1))
    (success, rotation_vector, translation_vector) = cv2.solvePnP(model_points, image_points, camera_matrix, dist_coeffs, flags=cv2.SOLVEPNP_ITERATIVE)
    one=rotation_vector[0][0]*180/3.14
    sec=rotation_vector[1][0]*180/3.14
    thd= rotation_vector[2][0]*180/3.14
    
    return(one,sec,thd)

eye_to_take_final=[]#1 for left
for no in range(2):
    eye_to_take=[]
    arr_vid=os.listdir(path_dict[no])
    for i in range(len(arr_vid)):
        video_path=path_dict[no]+str(arr_vid[i])
        cap=cv2.VideoCapture(video_path)
        predrig=[]
        rc,lc=0,0
        while(cap.isOpened()):
            ret , frame=cap.read()
            if ret == True:
                frame=cv2.resize(frame,(640,360))
                gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
                shape1=np.array([])
                rects1=detector(gray,0)
                for rect in rects1:
                    shape = predictor(gray,rect)
                    shape1 = face_utils.shape_to_np(shape)
                if(shape1.any()==0):
                    #predlef.append('e')
                    #predrig.append('e')
                    continue 
                one,sec,thd=angl(gray, shape1)
                if(-45<sec<-15 or 15<sec<45):
                    if(sec<0):
                        rc+=1
                    if(sec>=0):
                        lc+=1
            else:
                break
        if(rc>=lc):
            eye_to_take.append(0)
        else:
            eye_to_take.append(1)
        print(i)
    eye_to_take_final.append(eye_to_take)

eye_to_take_final

np.save(path_dict[0]+"eye_to_take_final",eye_to_take_final)

#for right eye 0, for left eye 1 in eye_to_take_final
arrq=[]
for no in range(2):
    arr_vid=os.listdir(path_dict[no])
    for i in range(len(arr_vid)):
        
        video_path=path_dict[no]+str(arr_vid[i])
        cap=cv2.VideoCapture(video_path)
        predrig=[]
        while(cap.isOpened()):
            ret , frame=cap.read()
            if ret == True:
                gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
                shape1=np.array([])
                rects1=detector(gray,0)
                for rect in rects1:
                    shape = predictor(gray,rect)
                    shape1 = face_utils.shape_to_np(shape)
                if(shape1.any()==0):
                    #predlef.append('e')
                    predrig.append('e')
                    continue
                
                if(eye_to_take_final[no][i]==0):
                    eye_img=reye(frame,shape1)
                    eye_img=cv2.cvtColor(eye_img,cv2.COLOR_BGR2GRAY)
                else:
                    eye_img=leye(frame,shape1)
                    eye_img=cv2.cvtColor(eye_img,cv2.COLOR_BGR2GRAY)
                
                img=cv2.resize(eye_img, (50,50))
                img=np.reshape(img, ([1,50,50,1]))
                pred2=np.argmax(model.predict(img))
                predrig.append(pred2)
            else:
                break
        arrq.append(predrig)
        cap.release()
        cv2.destroyAllWindows()

model = Sequential()
model.add(Convolution2D(32, (2,2), input_shape=(50,50,3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))

model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))


model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2), padding='same'))
model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))


model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
model.add(Convolution2D(64, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))


model.add(Convolution2D(32, (2,2), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))

model.add(Convolution2D(64, 2, activation='relu',padding='same'))
#model.add(ZeroPadding2D((1, 1)))
model.add(MaxPooling2D(pool_size=2,padding='same'))
#model.add(Dropout(0.3))


model.add(Flatten())
model.add(Dense(1024, activation='relu'))
#model.add(Dropout(0.30))
#   model.add(Dense(512, activation='relu'))
#   model.add(Dense(1024, activation='relu'))
model.add(Dropout(drop))
model.add(Dense(2))
model.add(Activation('softmax'))
model.load_weights("./drive/My Drive/neuro/cerv/sideorcenter.hdf5")
# 0 ek side and center and 1 required side for CD

f= open(path_dict[0]+"cerv.txt","w")
f.write("vid,feature,label\n")

arrq_count=0
for no in range(2):
    arr_vid=os.listdir(path_dict[no])
    for i in range(len(arr_vid)):
        video_path=path_dict[no]+str(arr_vid[i])
        cap=cv2.VideoCapture(video_path)
        arr=arrq[arrq_count]
        arrq_count+=1
        vid=arr_vid[i].split(".mp4")[0]
        c=0                                                 # count h frames ka
        p=0

        while(cap.isOpened()):
            ret , frame=cap.read()
            if ret == True:
                if(arr[c]==1):# yaha check kr rhe h 
                    gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
                    shape1=np.array([])
                    rects1=detector(gray,1)
                    for rect in rects1:
                        shape = predictor(gray,rect)
                        shape1 = face_utils.shape_to_np(shape)
                    if(shape1.any()==0):
                        continue
                    one,sec,thd=angl(gray, shape1)
                    if(-45<sec<-15 or 15<sec<45):
                        if(sec<0):
                            eye=reye(frame,shape1)
                        else:
                            eye=leye(frame,shape1)
                            eye=cv2.flip(eye,1)
                        #eye = cv2.cvtColor(eye, cv2.COLOR_BGR2GRAY)
                        eye = cv2.resize(eye, (50,50))
                        eye = np.reshape(eye, (1,50,50,3))
                        pred=np.argmax(model.predict(eye))
                        p = pred+p
            else:
                break
            c+=1
        cap.release()
        cv2.destroyAllWindows()
        print("vid : ",i, p,c)
        if (c!=0):
            f.write(str(vid)+","+str(p/c)+","+str(0)+"\n")
        else:
            f.write(str(vid)+","+"can't detect"+","+str(0)+"\n")
        
        
    f.write("\n")
    f.write("\n")

f.close()

